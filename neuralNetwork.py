'''
 3층 신경망 구현
 입력부터 처리까지 - 순방향 처리
 
  - 구성 -
 입력층(0층)은 2개의 뉴런
 첫 번째 은닉층(1층)은 3개의 뉴런
 두 번째 은닉층(2층)은 2개의 뉴런
 출력층(3층)은 2개의 뉴런
'''

import numpy as np

def sigmoid(x):
    return 1/(1+np.exp(-x))

def identity_function(x):
    return x
    
X = np.array([1.0, 0.5])
 # 입력층  

# ========= 0 -> 1 ========= #  
W1 = np.array([[0.1, 0.3, 0.5], [0.2, 0.4, 0.6]])
 # 0층에서 1층으로 갈 때 계산되는 가중 신호
B1 = np.array([0.1, 0.2, 0.3])
 # 0층에서 1층으로 갈 때 계산되는 편향

A1 = np.dot(X, W1) + B1
 # 행렬 연산
Z1 = sigmoid(A1)
 # 시그모이드 함수를 사용해 연산값 처리

 # ========= 1 -> 2 ========= # 
W2 = np.array([[0.1, 0.4], [0.2, 0.5], [0.3, 0.6]])
 # 1층에서 2층으로 갈 때 계산되는 가중 신호
B2 = np.array([0.1, 0.2])
 # 1층에서 2층으로 갈 때 계산되는 편향
 
A2 = np.dot(Z1, W2) + B2
 # 행렬 연산(0->1층 연산값과 1->2층 가중 신호의 계산) 
Z2 = sigmoid(A2)
 # 시그모이드 함수를 사용해 연산값 처리
 
 # ========= 2 -> 3 ========= # 
W3 = np.array([[0.1, 0.3], [0.2, 0.4]])
 # 2층에서 3층으로 갈 때 계산되는 가중 신호
B3 = np.array([0.1, 0.2])
 # 2층에서 3층으로 갈 때 계산되는 편향

A3 = np.dot(Z2, W3) + B3
 # 행렬 연산(1->2층 연산값과 2->3층 가중 신호의 계산)
Y = identity_function(A3)
 # 항등함수를 사용해 연산값 처리
 
print(Y)
 # 최종 결과 출력